# 一种用于NDN的安全的链路状态路由协议

> 原文地址：[A Secure Link State Routing Protocol for NDN](https://github.com/SunnyQjm/ndn-paper-translation/raw/master/original_paper/nlsr_a_secure_link_state_routing_protocol_for_ndn_2018.pdf)

## 摘要（Abstract）

命名数据链路状态路由协议（NLSR，*Named-data Link State Routing protocol*）是一个用作NDN网络域内路由的协议。很很多IP网络下的路由协议一样，它也是一个应用层的协议，不同的是NLSR使用NDN的兴趣包和数据包来更新路由信息，直接受益于NDN内建的数据认证机制。NLSR的设计首次于2013年开始开发，并在2014年八月第一次部署在NDN测试床上，在此期间NLSR的设计经历了巨大的变化。遵循应用程序驱动的设计方法，NLSR的开发同时推动了NDN库（*NDN libraries*）信任（*trust*）和安全（security）功能的开发，以及NDN的转发守护进程和 *ChronoSync* 中许多特性的支持。在本文中，我们将介绍NLSR当前的设计和实现，与基于IP的路由协议相比主要有以下几点主要区别：

- 命名方式（*naming*）：NLSR使用一个适用于路由器、安全密码（*keys，包括公私钥那些*）、和路由更新的层次化命名方案；
- 安全（*security*）：NLSR使用一个适用于单个管理域的层次化信任模型；
- 路由信息分发（*routing information dissemination*）：NLSR使用 *ChronoSync* 来传送路由更新；
- 多路径路由（*multipath routing*）：NLSR使用一个给多路径转发选项排序的简单算法。

虽然NLSR是作为单一域下的路由协议被设计的，但它的设计模式可以为未来开发域间路由协议提供有用的参考。

> 术语索引（*Index terms*）：路由协议（*Routing protocols*），下一代网络（*next generation network*），计算机安全（*computer security*）

## 介绍（Introduction）

命名数据网络（*NDN*）`[1,2,3]` 是一种以内容为中心的网络架构，用来解决TCP/IP网络中的网络使用和未解决的问题。NDN颠覆了传统的“把数据包从一个终端传输到另一个终端的”网络服务模型，它采用“拉取命名数据”的网络模型。通过显示的给数据包命名和签名，并维护有状态的转发平面 [4]，NDN提供了一些现有的IP网络很难实现的功能特性，例如：网内缓存（*in-network caching*），多播交付（*multicast delivery*），多路径转发（*multi-path forwarding*）和数据跟踪（*data provenance*）。

一个NDN的路由协议主要有两个功能，传播路由更新以及计算到命名前缀（*name prefix*）的路由。由于NDN采用层次化命名方案，并且NDN的转发语义是IP的一个超集（*虽然不太合理，但是如果NDN采用点分十进制给数据进行命名，并且使用单路径路由，那么NDN路由转发的语义和 IP下的类似了*），所以NDN可以使用IP下的任何路由算法来计算最佳路径（*best route*），例如：链路状态路由算法（*link-state routing protocol*）或距离向量路由算法（*distance-vector routing protocol* ）。然而，一个NDN的路由协议需要为数据包的转发提供多个下一跳，并以此来支持NDN的多路径转发（*multipath forwarding*），其中包括通向一个数据生产者（*data producer*）的多条路径和通向多个数据生产者的路径（两种方式在前缀可达性语义上存在差异，需要在路由协议设计中加以考虑，参见 `[1, 4.1节]` 以及本文的2.3节）。此外，NDN路由协议需要传播命名前缀而不是IP地址前缀的可达性信息，更重要的是需要用NDN的兴趣包和数据包而不是IP数据包来交换路由信息，这样做能使得路由协议受益于NDN内建的数据验证的能力。

这篇文章主要介绍了NLSR的设计和实现，它是一个用于NDN的路由协议。自我们在2013年粗略的描述出NLSR的初版设计 `[5]` 算起，该设计经历过大量的修改。在过去的四年里，我们通过实际的开发部署（*real implementations*）和实验测量（*experimentation*），对NDN和NDN应用程序的开发方法有了更深入的了解。本文的目标是论证使用NDN来实现路由协议的可行性和好处，并与整个社区分享我们的经验和观察。

NLSR与基于IP的链路状态路由协议相比主要有以下几点不同：

- ### 命名（Naming）

  NLSR使用层次结构的名称来标识路由器、路由进程、路由数据和密钥，因为他们之间的关系本质上是层次结构的。这种设计方式便于实现路由安全（*具体实现参见下文*），而且还允许NLSR使用所有类型的通信通道（*communication channel*），例如：它可以以同样的方式使用以太网、IP、TCP/UDP通道，因为它不依赖于特定类型的地址。相反，基于IP的链路状态路由协议（*如 OSPF [6]* ）通常使用一个地址作为标识符，例如IP地址。这种方式存在几个弊端，首先，它引入了对特定类型地址的依赖，这些地址通常嵌入在路由器的配置和其它管理功能中；其次，标识符是不稳定的，即它会随着位置的改变而改变；第三，标识符缺少上下文信息，而上下文对管理和安全都是很重要的。此外，这些协议没有显示的命名路由进程、路由数据和密钥，如果没有给这些实体和关系赋予有意义的名字，则很难监视路由系统并诊断它的问题。

- ### 安全（Security）

  由于每个NLSR路由信息都是由一个包含签名的NDN数据包所携带的，因此路由器可以验证每个路由消息的签名，以保证它是由它所声明的源路由器产生的，并且在传输的过程中没有被篡改。我们设计了一个用于单个域中路由的分层信任模型，该模型基于域中的公共管理结构和操作实践（*based on common management structures and operational practices in a domain*），以验证用于给路由消息签名的密钥。NLSR中的名称反映了路由实体之间的关系，允许使用NDN信任模型 [7] 自动派生签名密钥并验证收到的路由更新。

- ## 多路径转发（Multi-path Forwarding）

  IP网络中，为了避免转发循环的发生，使用单个最佳下一跳来转发包或限制其转发到多个等成本的路径。而NDN在转发过程中有内置的循环检测，可以自由的利用多个路径。NLSR为每个名称前缀构建具有多个下一跳的FIB条目，即使名称前缀是由单个路由器发起的。

在本文的其余部分，我们首先介绍NDN的基本概念；并在第二部分讨论相关工作；接着在第三部分，我们阐明了在命名、信任、LSA传播和多路径路由计算方便的设计选择以及背后的原理；在第四部分详细介绍，第五部分展示实验结果，并在第六部分分享我们的开发和部署经验以及教训，最后在第七部分对我们的工作做一个总结。

## 背景及相关工作（Background and Related Work）

- ### 命名数据网络（Named Data Networking）

  NDN中的通信时接收者驱动的，数据消费者通过交换两种类型的数据包，兴趣包（*Interest*）和数据包（*Data*）来进行通信。数据消费者将想要获取的数据块的名字放入兴趣包（*Interest*）中，并将其发送到网络当中。当路由器接收到兴趣包，它首先会检查内容缓存（CS，*Content Store*），其中内容缓存保存了先前接收到的数据，用以检索匹配的数据。如果在 *CS* 中找到了相匹配的数据包（*Data packet*），它会将匹配到的数据包沿着收到兴趣包的接口发回。否则，路由器将会检查未决兴趣表（PIT，*Pending Interest Table*），如果在PIT中存在与刚收到的兴趣包相同名字的表项，则将兴趣包到来的接口添加到该表项的接口列表当中，这样在匹配的数据包到来时，可以向所有兴趣包到来的接口发送一个数据包的拷贝。最后，如果兴趣包没有没有匹配到PIT中的表项，那么它将会被转发到下一跳。一旦兴趣包到达一个存有所需数据的节点，对应的数据包便会沿着PIT构建出的反向路径逐跳返回到原始的数据消费者。

  与IP路由相比，NDN的有状态的转发平面改变了路由（*routing*）和转发（*forwarding*）的基本关系——转发决策不仅基于路由协议产生的路由和路由排名，还取决于一些其它的因素。更具体的说，通过维护PIT，转发平面可以测量每个下一跳接收数据的性能（*例如：RTT*）。当兴趣包在FIB表中存在多个下一跳时，一个与兴趣包名称相匹配的“转发策略”将根据路由的排名、转发平面度量结果和本地配置的策略决定要转发到哪个下一跳。需要注意的是，路由协议产生的对多个下一跳的排序，在转发平面收集到测量结果之前将初始的兴趣包转发出去以及在使用的路由失效时探索替代路由的过程中也是很重要的。

- ### NLSR的演变（Evolution of NLSR）

  NLSR的设计自2013年第一次被发表 `[5]`，在过去的几年里有了显著的发展。最初的设计使用 *CNNx* `[9]` 提供的同步机制来在路由器之间传输链路状态通告（LSA，*Link State Advertisements*）。然而，通过在一个12个节点的测试床上进行了大量的测试后，我们发现了使用 *CNNx sync/repo* 来实现存在的几个问题，包括较高的内存消耗、无法从 *repo* 中删除信息以及在更新速率很高的情况下无法正确的通知NLSR同步路由更改。这些问题使得我们无法在2013年将这个版本的NLSR部署我们的大规模测试床上。

  在2014年，我们开发了一个包含新的转发守护进程和开发库的NDN平台 `[10]`，我们重新设计并实现了NLSR使得它在新的NDN平台下能够更好的工作。几个主要的设计改变显著的提升了NLSR的性能，包括使用 *ChronoSync* `[11]` 来分发LSA，将一个路由器注册的所有名称前缀都放到一个 *LSA* 里来分发以及使用转发平面通知（*forwarding plane notifications*）来检测链路故障（*更详细的信息请参考3.7节* ）。新版本的NLSR实现 `[12]` 于2014年8月发布并部署在洲际的NDN测试床上。

- ### 相关工作（Related Work）

  Dai 等人提出的路由协议 `[13]` 表面上与NLSR类似，但还是与NLSR存在以下几个方面的不同：

  - 首先，它不是设计用于ICN（内容中心网络，*Information Centric Networking*）/NDN网络的，相反，它使用IP数据包来传递路由更新并且没有解决路由安全性问题；

  - 其次，它使用OSPF路由算法来收集网络拓扑信息并计算最短路径而NLSR则是使用 *ChronoSync* 来传播 *LSAs*，因此，它也继承了OSPF存在的问题（*例如：缺乏用于管理和安全的命名，并且只能计算到目的地的等成本多路径*）；

    > 此外，*ChronoSync* 是由接收方驱动的，这意味着路由器只会在有CPU周期时才去请求 *LSA*，因此路由器不太可能被一连串的更新淹没

  - 第三，Dai 等人提出的路由协议中的多路径转发功能仅限于多个生产者宣布的内容，例如，支持多个服务器副本之间的 *anycast*，而NLSR可以沿着多个路径将兴趣包转发到同一生产者或者同一数据的多个生产者。

  在我们最初版本的NLSR `[5]` 发布后，陆续也有一些人开发了几个NDN/ICN路由协议。链路状态内容路由（LSCR `[14]`，*Link State Content Routing*）和基于距离的内容路由（DCR `[15]`，*Distance-based Content Routing*）旨在避免产生永久的路由循环，当一个名称前缀被网络的多个站点所复制时，它们的性能要优于传统的路由协议。LSCR使用与基于IP的链路状态路由相同的方式来传输邻接信息，只不过时有选择的传播前缀信息——在一个前缀的多个实例中，它只将最近的实例传播给它的邻居。DCR提供了不需要路由器知道整个网络拓扑结构的情况下的名称前缀的可达性。DCR使用距离信息来计算前缀（*prefix*）的路径，与LSCR类似，它不会传播有关网络中所有名称前缀副本的信息。

  在LSCR和DCR中，一个常见的问题就是，路由通告的选择性转发可能导致某些数据无法访问（*selective forwarding of routing advertisements may cause some data to be unreachable*）。在NDN中，向网络宣告（*announcing*）一个名称前缀只是意味着拥有该命名空间下的部分数据，但不一定拥有该命名空间下的所有数据，NDN的自适应转发平面可以尝试替代路径来检索所有需要的数据。举个例子来说，一个向网络宣告 `/com/cnn` 前缀的路由器可以提供以 `/com/cnn/sports` 和 `/com/cnn/entertainment` 作为前缀的数据，但不一定能提供所有以 `/com/cnn` 作为前缀的数据。相反的，一个IP路由器如果宣告一个地址前缀，则意味着他能到达该地址前缀下的所有节点。这种语义差异意味着NDN路由器需要传播由不同路节点产生的相同名称前缀的通告，以确保数据检索（*an NDN router needs to propagate advertisements for the same name prefix originated by different nodes to ensure data retrievalm*， *参见* `[1, 4.1节]`）。此外，使用选择性的通告只有当路由器给每个前缀使用一个单独的数据包来通告时，才能节省CPU和带宽。在这方面 `[14]` 和 `[15]` 与我们最初的设计 `[5]` 相比确实有一定的优势，在我们最初的设计中，对于每一个名称前缀都使用一个单独的LSA来通告，不过在我们当前NLSR最新的设计中在一个LSA中申明所有由路由器发出的前缀。我们最初设计是基于这样一个考虑：当前缀列表变得很大时必须对LSA进行分段。然而，由于NLSR是为域间路由设计的，因此每个路由器发出的前缀列表应当足够小，以便能放入单个数据包中（在当前NDN平台的实现中，单个数据包的最大size为8800字节）。因此，我们改变了设计以减少LSA数据包的数量 。

## 设计（Design）

