# NLSR: 命名数据链路状态路由协议

> paper地址：[NLSR: Named-data Link State Routing Protocol](https://named-data.net/wp-content/uploads/2013/07/nlsr-final.pdf)

## 摘要（Abstract）

本文介绍了一种用于命名数据网络（NDN， *Named Data Network*）的路由协议——命名数据链路状态路由协议（NLSR，*Named-data Link State Routing Protocol*）的设计。由于NDN使用名称来标识和检索数据，所以NLSR将可达性传播到名称前缀而不是IP前缀。此外，NLSR区别于基于IP的链路状态路由协议，有两个最基本的特征。首先，NLSR使用兴趣包（*Interest Packet*）和数据包（*Data Packet*）来传播路由更新，直接受益于NDN内生的数据包验证，更加安全；其次，NLSR为每一个名称前缀生成一个按**一定规则**（*比如，开销*）排好序的转发选项列表，给实现NDN自适应的转发策略做支撑。在本文中，我们将讨论NLSR主要设计思想，主要包括以下几个部分：

- 一个适用于路由器、安全密码（*keys，包括公私钥那些*）、和路由更新的层次化命名方案；

- 一个适用于单个管理域的层次化信任模型；
- 一个逐条同步协议，用于替代传统的使用网络泛洪的方式传播路由更新；
- 一个给多路径转发选项排序的简单算法。

与基于IP的链路状态路由协议相比，NLSR提供更高效的路由更新传播，拥有内建的路由更新认证而且原生支持多路径转发。

## 关键词（Keywords）

Routing, NDN, Trust Model

## 介绍（Introduction）

命名数据网络（NDN）[3, 4]是一种新型的网络体系结构，是对当前基于IP的Internet体系结构一次大刀阔斧的整改。NDN在每个包（*packet*）中都放置一个数据名称，而不是携带目标IP地址；数据的消费者发送一个兴趣包（*Interest packet*）来获取数据，兴趣包中包含了所要获取数据的名称标识，一个包含相同名字的数据包（*Data packet*）可以用来响应这个兴趣包（*Interest Packet*），数据包中包含名称、数据以及一个由最初的数据生产者生成的对该数据包的签名。通过给数据包进行显示的命名和签名，NDN网络支持一系列的特性，包括：网内缓存（ *in-network caching*）、多路径转发（*multipath forwarding*）、多播数据交付（*multicast data delivery*）和数据真实性校验（*data authenticity*）。

为了能使NDN在广域网（*wide-area networks*）上能很好的工作，一个NDN的路由协议需要计算并将合适的转发条目插入到NDN节点的FIB（*NDN网络的转发表*）表中。每个FIB表项包含一个名称前缀和一个或多个下一条出口记录，NDN可以根据FIB表信息来转发和FIB表项中名称前缀相匹配的兴趣包（*Interest packet*）。IP网络下的路由协议必须使用单一的最佳下一跳或者限制其转发到多个等成本的路径，来避免循环路径的产生，而NDN网络有内建的预防循环路径产生的机制，所以可以自由的利用多个路径。因此，**NDN网络需要一个能够支持基于名称进行多路径路由的路由协议**。

我们之前为NDN开发了一个**OSPFN** [8] 路由协议，它是OSPF路由协议的一个扩展版本，适用于NDN，并将其部署在NDN的测试床上。OSPFN定义了一种新的不透明的链路状态通告（LSA），用于在路由消息中携带名称前缀。它为每个名称前缀计算出最佳的下一跳，并插入到FIB表当中，网络管理员可以手动为OSPFN配置一个除了最佳下一跳以外的可选下一跳列表，并插入到FIB表中。虽然OSPFN可以构建基于名称前缀的FIB表，但同样存在很多限制。和传统的基于IP的路由协议一样，OSPFN仍然使用IP地址作为路由器的ID，依赖于GRE隧道来跨越传统的IP网络，并且对于每个名称前缀值计算一个最佳的下一跳。我们在部署OSPFN的过程中发现，管理IP地址和隧道是主要的操作问题，并且由于对多路径的支持不够，限制了NDN原有的优势（*内建的网内缓存和防路径循环机制等等*）。

在本文接下来的部分，我们将介绍命名数据链路状态路由协议（NLSR）的详细设计，并使其工作在NDN网络上（**换句话来说，NLSR使用NDN的兴趣包和数据包来交换路由消息**）。OSPFN是一种与OSPF类似的链路状态协议——链路状态通告（LSA）在整个网络中传播，每个路由器构建出了完整的网络拓扑。和OSPF有所区别的是，在OSPFN中，路由器不再只计算一条最短路径，而是对所有符合策略的下一跳进行排名，并按序写入FIB表当中，其在本质上提供了一个基于名称的多路径路由表，被用来作为NDN转发策略的输入（*NDN的可以利用多路径信息进行丰富的转发策略定制*）。

NLSR使用名称而不是IP地址来标识路由器和链接，因此它可以使用任何底层的通信渠道（*例如：以太网、IP隧道、TCP/UDP隧道等等*）来交换路由消息。**NLSR直接受益于NDN内建的数据认证机制**：由于每个路由更新消息都是由NDN数据包（*Data packet*）所携带的，并且NDN中每个数据包都带有数据生产者的签名，所以路由器可以通过验证每个路由消息的签名来保证它是由指定的原始路由器生成的，并且在传播过程中没有被篡改（***数据的完整性和有效性校验***）。

作为NDN上第一个分布式的路由协议，NLSR的设计需要回答以下几个在NDN上独有的问题：

- **命名**（*Naming*）：如何给**路由器**（*routers*）、**链接**（*links*）和**路由更新**（*routing updates*）命名？
- **信任**（*Trust*）：如何**分发路由器的加密密钥**（*cryptographic keys*），以及如何获得对这些密钥的信任
- **信息传播**（*Information Dissemination*）：如何**在网络中传播路由更新**？（*基于IP的路由协议采用推的方式将路由更新发送给其他路由器，而在NDN网络中则需要路由器主动去拉取所有更新*）
- **多路径**（*Multipath*）：如何产生并排序下一跳以促进多跳转发？

在本文中，我们描述了我们是如何选择我们的设计方案的，并且阐明了这些选择背后的基本原理。我们的目标不是发明一种新的路由方案（*因为在本质上来讲NLSR也是一种链路状态路由协议*），而是为了证明在NDN网络上建立一个路由协议的可行性和优势。

由于NDN的自适应多路径转发能够处理在转发平面上存在的多个数据包传递问题（*例如：环形路径*），使得路由平面的限制放宽了，设计可以更加自由。举例来说，路由协议将不用关心路由平面是否会产生环路，因为NDN的FIB表项的合并操作将使得环路的产生变得不可能。因此，一些原先在IP网络中不起作用的路由协议设计现在可以在NDN网络中使用，并且新型路由的设计也成为可能。探索其它类型的路由设计将是我们未来的工作之一。

本文接下来的部分将包含以下内容：第二节简要介绍了NDN网络所提供的一些基本的功能，第三节介绍了设计的细节，第四节展示了实验测量和结果，第五节讨论一些相关的工作，第六节将对全文进行总结。

## NDN的基本功能（NDN PRIMARY）

NDN在其转发平面 [3] 中有三个主要的组件：

- **转发信息库**（FIB，*Forwarding Information Base*）：FIB即为NDN网络中的转发表，用于存储转发条目，将兴趣包与**相匹配数据**（*与兴趣包名称相同的数据包*）的潜在来源相关联。与IP网络中的转发表不同的是，对于每一个名称前缀，他的传出端口（下一跳）不止一个，而是一个列表。FIB表中的表项可以手动插入，也可以利用NDN路由协议中的控制平面进行填充。
- **未决兴趣表**（PIT，*Pending Interest Table* ）：PIT表存储了未被满足的兴趣包以及他们到来的face接口，因此数据包可以通过查询PIT表项被路由回到原始的发送兴趣包的节点。
- **内容缓存**（CS，*Content Store*）：CS用来缓存数据。

当一个兴趣包到达路由器，路由器首先会检查`CS`中是否有相匹配的数据，如果有则将数据包从收到兴趣包的端口上转发出去，否则将其添加到PIT表当中（*同时记录下兴趣包的入口Face*）。如果PIT表中存在相同名称的条目，新的端口编号将被添加到端口列表当中，以便可以在数据包到来时向所有兴趣包到来的端口发送一个数据包的副本。最后，如果兴趣包是第一次插入PIT表中（*即 PIT表中不存在相同名字的兴趣包*），则该兴趣包将通过查询FIB表转发至下一跳，如果FIB条目中存在多个下一跳，则一个成为“转发策略”的模块将会决定在多条路径同时存在的情况下，该如何转发兴趣包。

## 设计（Design）

作为一种链路状态路由协议，NLSR通过分发链路状态通告（LSAs）来构建网络拓扑并分发名称前缀可达性。NLSR路由器建立并维护与邻接路由器的关系，每当它检测到任意链接的故障或恢复，或者是发现一个新的邻居，都会生成一个新的LSA并传播到整个网络当中。此外，NLSR路由器还会向全网通告本地静态配置的名称前缀和local的内容提供者动态注册的前缀。当任意的名称前缀被添加或者删除时，NLSR同样会生成一个新的LSA并将其传播到全网。最新版本的LSAs将会存储在链路状态数据库（LSDB，*Link State Data Base*）。

这种拓扑和可达性信息的分发方式最初看起来似乎有点过于直接了，因为在IP路由器中已经实现了类似的功能。然后，由于在NLSR中使用NDN的兴趣包和数据包来进行路由更新，路由协议的设计就必须对IP地址和IP数据推送等一些熟悉的概念（*例如：在IP网络中任何节点都可以简单的将任何数据包发送到任何其它的节点*）做一些转变。因此，我们需要根据数据的名称和数据的获取方式来思考我们的设计。更具体来说，我们需要一个针对路由器和路由更新的系统的命名方案（*3.1节详细介绍*）。同时，路由器需要在不知道其它路由器何时会产生新的路由更新的情况下迅速的拉取到最新的路由更新，因为网络拓扑和网络名称前缀随时可能发生更改（*而一旦网络拓扑或者名称前缀发生改变，就会产生新的路由更新*）。

在路由功能方面，NLSR与之前的链路状态路由协议主要有以下两个方面的不同：

- NLSR为每个名称前缀提供多个路由，而不是提供单个最短路径；
- NLSR对每个LSA都进行签名和验证，这样能保证每个路由器只产生自己的前缀和连接信息（*不能伪造*）

我们将在3.4节介绍我们的路径计算算法， 在3.6节介绍NLSR的信任模型。

作为开发基于NDN的路由协议的第一步，NLSR最初的设计运行在单个路由域中，并且只使用简单的单权限信任模型。我们现在正在将NLSR部署到我们的NDN测试床上，我们相信这一初步设计的部署经验可以为我们以后开发基于NDN的域间路由协议和设计域间路由的信任模型起到抛砖引玉的效果。

- ### 命名（Naming）

  也许我们设计中最重要的部分便是在路由系统中对每个元素及其相关的公钥设计一个合适的命名方案。基于我们现有网络的结构和操作经验，分层命名的方案可以很好的表示系统中各个组件的关系，还可以很容易区分路由器是否属于同一个网络，同时为给定的路由过程生成消息也变得简单。同样的，分层命名的方案还有利于将密钥和其拥有者关联起来。

  在我们的设计中，每个路由器的命名都是根据它所在的网络，所属的站点以及其所属站点为该路由器分配的名字组成的，即 `/<network>/<site>/<router>`。例如，一个位于亚特兰大（*Atlanta*）的一个PoP中的路由器的一个可能命名时这样子的：`/ATT/AtlantaPop1/router3`。以这种方式命名的话，如果两个路由器共享相同的名称前缀`/<network>`，则可以判断这两个路由器属于同一个网络下；如果两个路由器共享相同的名称前缀`/<network>/<site>`，则可以判断这个两个路由器属于同一个网络下的同一个站点。采用这种分层命名的方式，可以很容易的过滤出错误的路由消息。

  路由器上NLSR进程的名字时根据路由器的名称命名的，具体的就是路由器的名称作为前缀，后面跟上NLSR进程的名字`NLSR`，即`/<network>/<site>/<router>/NLSR`。这个路由进程名字用于在相邻NLSR路由器节点之间传递周期性的`info`消息，可以用来检测链接是否失败，以及检测NLSR进程本身的一些错误（*3.5节会详细介绍*）。

  在理想情况下，任何由NLSR进程产生的路由更新消息的命名都应该以该NLSR路由进程的名称作为前缀，这样就很容易可以辨别产生该消息的NLSR进程。换句话说，一个LSA的名称应该时类似这种格式的：`/<network>/<site>/<router>/NLSR/LSA`，这样可以标识该LSA是由指定的NLSR进程生成的。然而， 由于我们在实现的过程中使用了**CNNx** [5] 和 **Repo** [5] 来传播同步LSA消息，而 **CNNx repo** 严格限制了所有参与同步的消息都要共享相同的前缀，我们目前一个折衷的做法是所有路由器生成的LSA都共用一个前缀。我们为每个LSA使用相同的前缀`/<network>/NLSR/LSA`（*我们称之为 <LSA-prefix>*），并在此前缀后加上`/<site>/router`用以区分不同NLSR路由器生成的LSA。

- ### 链路状态通告（LSAs）

  NLSR设计了两种类型的LSA，分别是**邻接LSA**（*Adjacency LSA*）和**前缀LSA**（*Prefix LSA*），其中邻接LSA用于对外宣告一个NDN路由器与其所有邻居相连的活动的链路，而前缀LSA则用于对外宣告在当前的NDN路由器已经注册的名称前缀。他们所包含的内容如下表所示：

  | Type          | Content                                                      |
  | ------------- | ------------------------------------------------------------ |
  | Adjacency LSA | #Active Links (N), Neighbor 1 Name, Link 1 Cost, ...,Neighbor N Name, Link N Cost |
  | Prefix LSA    | isValid, Name Preﬁx                                          |

  <center>表 1  LSA所包含的内容</center>
  
  
  一个**邻接LSA**（*Adjacency LSA*）的命名通常是这样的：`/<LSA-prefix>/<site>/<router>/LsType.1/<version>`，其中`<router>`指的是产生该LSA的路由器的名字，`<version>`指的是LSA的版本号（*这个版本号是随时间变化的，路由器每产生一个新的同类型的 LSA，版本号就会改变*），在目前的实现里，LSA的`<version>`使用的是LSA创建时的时间戳（实际上，和OSPF类似，用序列号来表示也是可以的）。如表1所示，**邻接LSA**包含了所有与当前路由器相连的处于激活状态的链接，每一项包含邻居路由器的名字，和链路开销（*link cost*）。它是在路由器启动的时候创建的，且每当路由器的链接状态发生改变时（*路由器的链接状态的改变是由周期性的 `info` 兴趣包检测到的，在3.5节会*），都会创建新的**邻接LSA**。
  
    一个**前缀LSA**（*Prefix LSA*）的命名通常是这样的：`/<LSA-prefix>/<site>/<router>/LsType.2/LsId.<ID>/<version>`，需要提一嘴的是，每个名称前缀都是使用单独的**前缀LSA**来向外通告的。由于一个路由器通常需要宣告多个前缀，所以我们在前缀LSA的命名中使用*ID*来标识不同前缀的LSA（前缀LSA的ID可以是手动配置的，也可以是基于要宣告的名称前缀计算得来的）。我们这样设计**前缀LSA**是有所考虑的，如果我们将所有的前缀都塞到单个LSA中进行传播可能会放不下，而且更新的效率不高（*因为每当有前缀添加或删除的时候就需要生成新的前缀 LSA，如果所有的前缀都用一个前缀 LSA来通告的话，就会传递很多冗余信息*）。每个**前缀LSA**包含一个*isValid*标记（初始时，*isValid* = 1）和要宣告的前缀名称。当一个名称前缀被取消注册时，NLSR会将对应的**前缀LSA**的*isValid*标记设置为0，并且将新的LSA传播给其它节点，其它的NLSR节点收到这个LSA会将这个名称前缀从LSDB中删除并且更新FIB表项中对应的表项。
  
    为了移除由于路由器故障来不及移除的过时的LSA，每个路由器会周期性的为每个要通告的前缀生成新版本的前缀LSA，而且每个LSA会有一个生存期（*lifetime*），一旦生存期失效，这个LSA就会被路由器从LSDB中移除。因此，一旦某个路由器发生故障奔溃，其之前通告的的LSA不会在其它路由器的LSDB中保存太长时间，会很快失效。路由器在计算路由时，不应该收到NLSR中过时的LSA的影响，一旦路由器奔溃，其邻居将会更新它们LSA的状态，这样网络流量就不会向通往这个奔溃路由器的无效链路上传送了。因为我们不使用刷新机制来处理丢包和包损坏（这些将由 *CNNx Sync* 处理），而且过期的LSA并不影响路由计算，因此刷新器的刷新间隔可以设置成较大的间隔，例如：可以每天刷新一次。
  
- ### LSDB 同步（*LSDB Synchronization*）

  为了从概念上简化我们的设计，我们将LSDB看作一个数据的集合，把LSA的传播问题看作由路由器维护的LSDBs的同步问题。路由器周期性地交换他们LSDB的hash值来检测不一致性，如果发现不一致则从不一致中恢复。这种逐跳的同步方法可以避免不需要的网络泛洪，当网络稳定时，邻居之间只需要相互交换LSDB的hash值即可，而不用互相传递所有的LSAs。此外，这种数据同步方式时接收方驱动的，这意味着路由器只会在具有CPU周期时去拉取LSAs，因此路由器基本不会被频繁的路由器更新整奔溃。

  我们当前的实现使用的是 *CNNx* 同步协议或 *Sync* [5] 来将LSAs传播到邻居路由器。*Sync*和*CNNx*的*Repo*相关联，它允许应用程序在*Repo*中定义命名数据集合，这个集合被称之为*slice*，并保持当前路由器与相邻路由器中定义相同的*slice*的同步。*Sync*会为*Slice*中所有的数据计算一个Hash树，并且在相邻路由器之间交换根Hash的值来检测不一致性。如何检测到Hash值不一致，则两个邻居节点会交换Hash树下一层节点的Hash值，直到他们检测到导致不一致性的叶子节点，两个邻居路由器就会交换对应的数据来达成新的一致性。

  ![image-20191217211352389](assets/image-20191217211352389.png)

  <center>图1 路由器之间使用 CNNx Sync/repo 相互传播LSA示意图（图中虚线代表周期性消息）</center>

  图1显示了LSA是如何在网络中传播的：

  - 为了同步包含*LSAs*的*Slice*，*Sync*协议（*路由器B*）周期性的对外发送被称为*Root Advise*的特殊兴趣包，这个兴趣包携带了发送路由器的*Slice*的hash值（***步骤 1***）；

  - 当路由器A创建了一个LSA，并把它写入到*Sync*的*Slice*当中（***步骤 2***），此时路由器A计算的Hash值与路由器B的不同；

  - 这将导致路由器A的*Sync*回复路由器B的 *Root Advise*（**通常，在两个路由器计算得到的hash值相同的情况下，是不需要回复 *Root Advise* 的，当路由器有有新的LSA产生或者移除时会导致路由器的Hash值不一致，此时才需要回复 *Root Advise***），这个回复中携带了路由器A本地计算得到的新的Hash值；（***步骤3***）

  - 收到回复后，路由器B的 *Sync* 会比对收到的Hash值，并递归的获取到Hash树下一层级的Hash值，直到定位到导致不一致性的叶子节点，最终，路由器B的 *Sync* 会识别出需要同步的数据（*这里所说的数据即为 NLSR 语境下的 LSA*），并发送对应的兴趣包将需要同步的数据从路由器A中拉取过来（***步骤 4 和 5***）；
  - 接着，路由器B的 *Sync* 会将新收到的数据名字发给本地的NLSR进行（***步骤 6***）
  - 然后路由器B的NLSR进程就会发送对应名字的兴趣包给本地的 *repo* 来拉取同步过来的LSA数据（***步骤 7 和 8***），最后更新到本地的LSDB当中（***步骤 9***）。

  每个 *Root Advise* 兴趣包都有一个存活期（*lifetime*），路由器在 *Root Advise* 兴趣包到期后会发送一个新的 *Root Advise* 兴趣包。这种周期性传输机制的设计是为了防止 *Root Advise* 兴趣包丢包的发生（*试设想，如果Root Advise 兴趣包的存活期无限大，会一直等待回复，如果 Root Advise 兴趣包在传输的过程中丢失了，而发送方又不知道，且不重传，那么发送方会以为没有新的更新，一直不去拉取最新的更新*），从而降低由于丢包带来的路由收敛延迟。但是，如果数据包的丢失率很低，频繁的发送 *Root Advise* 兴趣包亦会带来无意义的额外开销。在理想情况下，我们希望根据路由需求和网络特性来调整 *Root Advise* 兴趣包的发送频率。为了支持这个特性并解决 *CNNx Sync* 实现中的一些其它问题，我们正在致力于开发内建有同步机制的新版本的NLSR，以实现相同的LSA逐跳传播的效果。

- ### 多路径计算（Multipath Calculation）

  基于 **邻接LSAs**（*Adjacency LSAs*）提供的网络节点间的连接信息，每个NLSR节点都能构建出完整的网络拓扑。接着路由器只需运行一个简单的扩展 *Dijkstra* 算法便可以为每一个目的节点计算出多跳路由。从 **前缀LSAs**（*Prefix LSAs*）中，我们可以知道每个路由器都关联了哪些前缀。我们可以综合上述的信息计算出到达每个名称前缀的下一跳列表。

  我们设计的NLSR中某个路由器计算多路径路由的方式如下：

  - 首先路由器移除（并非断开，只是排除）到除了一个邻居外的其它直接相连的邻居的路劲（即，只保留一个直接相连的邻居）；
  - 然后使用 *Dijstra* 算法计算计算当前路由器到网络拓扑中其它所有节点的开销，并记录；
  - 接着对每一个邻居都重复上述过程；
  - 最后路由器到网络上任意的其它节点都会有多条路径，并且每条路径都有一个开销，然后根据开销进行排名，就能得到到每个目的地的排好序的下一跳列表。

  需要提一嘴的是，NLSR支持让用户自行配置对某个名称前缀最多能有几条路劲插入到FIB当中，这样当路由器的邻居很多的情况下FIB表的大小也是可控的。但是计算开销仍然会随着 *Face* 接口数量的增加而增加，因为我们需要遍历所有的 *Face* 接口来找到所有可能的路径。我们计划探索其它多路径计算算法来解决这个问题。
  

- 







































- 

